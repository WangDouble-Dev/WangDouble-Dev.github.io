
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>PHP面试准备 | Double Blog</title>
    <meta name="description"
        content="PHP include和require的区别 1.include 引入文件的时候，如果碰到错误，会给出提示，并继续运行下边的代码。require 引入文件的时候，如果碰到错误，会给出提示，并停止运行下边的代码。
2.include() 执行时需要引用的文件每次都要进行读取和评估，require() 执行时需要引用的文件只处理一次（实际上执行时需要引用的文件内容替换了 require() 语句）可以看出若有包含这些指令之一的代码和可能执行多次的代码，则使用 require() 效率比较高，若每次执行代码时相读取不同的文件或者有通过一组文件叠代的循环，就使用 include()，可以给想要包括的文件名设置变量，当参数为 include() 时使用这个变量。
3.incluce 在用到时加载；require 在一开始就加载；_once 后缀表示已加载的不加载。
预定义变量 $GLOBALS — 引用全局作用域中可用的全部变量
$_SERVER — 服务器和执行环境信息
$_GET — HTTP GET 变量
$_POST — HTTP POST 变量
$_FILES — HTTP 文件上传变量
$_REQUEST — HTTP Request 变量
$_SESSION — Session 变量
$_ENV — 环境变量
$_COOKIE — HTTP Cookies
$php_errormsg — 前一个错误信息
$http_response_header — HTTP 响应头
$argc — 传递给脚本的参数数目
$argv — 传递给脚本的参数数组
官方文档">
    <link rel="canonical" href="https://WangDouble-Dev.github.io/post/phper/" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css">
    
    <link rel="stylesheet" href="https://WangDouble-Dev.github.io/scss/style.min.6fd76f9357079467c4c99f3252388507d90341f626f93046f15e41f0fd47bf99.css">

    <meta property="og:title" content="PHP面试准备" />
<meta property="og:description" content="PHP include和require的区别 1.include 引入文件的时候，如果碰到错误，会给出提示，并继续运行下边的代码。require 引入文件的时候，如果碰到错误，会给出提示，并停止运行下边的代码。
2.include() 执行时需要引用的文件每次都要进行读取和评估，require() 执行时需要引用的文件只处理一次（实际上执行时需要引用的文件内容替换了 require() 语句）可以看出若有包含这些指令之一的代码和可能执行多次的代码，则使用 require() 效率比较高，若每次执行代码时相读取不同的文件或者有通过一组文件叠代的循环，就使用 include()，可以给想要包括的文件名设置变量，当参数为 include() 时使用这个变量。
3.incluce 在用到时加载；require 在一开始就加载；_once 后缀表示已加载的不加载。
预定义变量 $GLOBALS — 引用全局作用域中可用的全部变量
$_SERVER — 服务器和执行环境信息
$_GET — HTTP GET 变量
$_POST — HTTP POST 变量
$_FILES — HTTP 文件上传变量
$_REQUEST — HTTP Request 变量
$_SESSION — Session 变量
$_ENV — 环境变量
$_COOKIE — HTTP Cookies
$php_errormsg — 前一个错误信息
$http_response_header — HTTP 响应头
$argc — 传递给脚本的参数数目
$argv — 传递给脚本的参数数组
官方文档" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://WangDouble-Dev.github.io/post/phper/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-02-07T21:09:40+08:00" />
<meta property="article:modified_time" content="2024-02-07T21:09:40+08:00" /><meta property="og:site_name" content="Wang Double" />


    <meta name="twitter:card" content="summary"/><meta name="twitter:title" content="PHP面试准备"/>
<meta name="twitter:description" content="PHP include和require的区别 1.include 引入文件的时候，如果碰到错误，会给出提示，并继续运行下边的代码。require 引入文件的时候，如果碰到错误，会给出提示，并停止运行下边的代码。
2.include() 执行时需要引用的文件每次都要进行读取和评估，require() 执行时需要引用的文件只处理一次（实际上执行时需要引用的文件内容替换了 require() 语句）可以看出若有包含这些指令之一的代码和可能执行多次的代码，则使用 require() 效率比较高，若每次执行代码时相读取不同的文件或者有通过一组文件叠代的循环，就使用 include()，可以给想要包括的文件名设置变量，当参数为 include() 时使用这个变量。
3.incluce 在用到时加载；require 在一开始就加载；_once 后缀表示已加载的不加载。
预定义变量 $GLOBALS — 引用全局作用域中可用的全部变量
$_SERVER — 服务器和执行环境信息
$_GET — HTTP GET 变量
$_POST — HTTP POST 变量
$_FILES — HTTP 文件上传变量
$_REQUEST — HTTP Request 变量
$_SESSION — Session 变量
$_ENV — 环境变量
$_COOKIE — HTTP Cookies
$php_errormsg — 前一个错误信息
$http_response_header — HTTP 响应头
$argc — 传递给脚本的参数数目
$argv — 传递给脚本的参数数组
官方文档"/>

    
    
    

</head><body><nav class="navbar is-light" role="navigation">
    <div class="container">
        <div class="navbar-brand">
            <a href="/" title="home" class="navbar-item">
                <span class="logo">
                    <h1>Double Blog</h1>
                </span>
            </a>

            
            <a id="theme-toggle" class="theme-toggle" href="#">
                <img src="https://WangDouble-Dev.github.io/svg/sun.svg" alt="sun icon" class="theme-icon" />
            </a>

            <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
            </a>
        </div>

        <div class="navbar-menu">
            <div class="navbar-start">
                
                <a href="/post" class="navbar-item">Blog</a>
                
                <a href="/categories" class="navbar-item">Categories</a>
                
                <a href="/todo" class="navbar-item">Todo</a>
                
            </div>

        </div>
        <div class="search">
            <div id="fastSearch">
                <input id="searchInput" tabindex="0" placeholder="Search..">
                <ul id="searchResults">

                </ul>
            </div>
            <a id="search-btn" style="display: inline-block;" href="# ">
                <div class="icon-search"><svg class="search-svg" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></div>
            </a>
        </div>

        <script src="/js/fuse.min.js"></script> 
        <script src="/js/fastsearch.js"></script>

    </div>
</nav>

<script>
    
    document.addEventListener('DOMContentLoaded', function() {
        var burger = document.querySelector('.navbar-burger');
        burger.addEventListener('click', function() {
            burger.classList.toggle('is-active');
            document.querySelector('.navbar-menu').classList.toggle('is-active');
        });
    });

    
    function setTheme(theme) {
        let body = document.body;
        let themeIcon = document.querySelector(".theme-icon");
        if (theme === "dark") {
            body.classList.add("dark-mode");
            themeIcon.src = "https:\/\/WangDouble-Dev.github.io\/svg/moon.svg";
            themeIcon.alt = "moon icon";
        } else {
            body.classList.remove("dark-mode");
            themeIcon.src = "https:\/\/WangDouble-Dev.github.io\/svg/sun.svg";
            themeIcon.alt = "sun icon";
        }
        
        localStorage.setItem("theme", theme);
    }

    
    let theme = localStorage.getItem("theme") || "light";
    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (isDarkMode) {
        
        setTheme('dark');

    } else {
        
        setTheme('light');
    }
    setTheme(theme);

    
    document.getElementById("theme-toggle").addEventListener("click", function() {
        if (theme === "light") {
            theme = "dark";
        } else {
            theme = "light";
        }
        setTheme(theme);
    });



</script>

</header><main>
<div class="single-container">
    <div class="archive">
        <h1 class="title is-1">PHP面试准备</h1>
        <div class="title subtitle heading is-6">
            <div class="author-info columns is-vcentered">
                <div class="column">
                    <div class="columns is-vcentered is-mobile">
                        
                        <div class="column is-narrow">
                            <img src="/images/profile.jpg" class="author-image">
                        </div>
                        
                        <div class="column">
                            <p>Wang Double</p>
                            <p><time>February 7, 2024</time>
                            </p>
                        </div>
                    </div>
                </div>
                <div class="small-categories-container">
                    <a href="/categories/php">PHP</a>
                </div>
            </div>
        </div>
        <div class="content article-content">
            <div class="toc-container">
                
    <div class="post-toc">
        
            <aside>
                <button id="tocButton" ><h4 id="contents" style="margin-left: 1vw;color:rgb(96, 134, 180);margin-bottom: 0;">CONTENTS</h4></button>
                <div id="hide"><nav id="TableOfContents">
  <ul>
    <li><a href="#php">PHP</a>
      <ul>
        <li></li>
        <li><a href="#php支持多线程吗">PHP支持多线程吗？</a></li>
      </ul>
    </li>
    <li><a href="#编程基础">编程基础</a>
      <ul>
        <li><a href="#什么是aop面向切面编程">什么是AOP面向切面编程</a></li>
        <li><a href="#雪花算法">雪花算法</a></li>
      </ul>
    </li>
    <li><a href="#mysql">MySQL</a>
      <ul>
        <li><a href="#三范式">三范式</a></li>
        <li><a href="#innodb和myisam">InnoDB和MyISAM</a></li>
        <li><a href="#事务的特征">事务的特征</a></li>
        <li><a href="#数据库事务隔离级别">数据库事务隔离级别</a></li>
        <li><a href="#数据库事务隔离级别相关的并发问题">数据库事务隔离级别相关的并发问题</a></li>
        <li><a href="#什么是mvcc">什么是MVCC</a></li>
        <li><a href="#mysql的可重复读隔离级别是如何解决幻读的">MySQL的可重复读隔离级别是如何解决幻读的</a></li>
        <li><a href="#mysql-有哪些锁">MySQL 有哪些锁？</a></li>
        <li><a href="#mysql索引数据结构">MySQL索引数据结构</a></li>
        <li><a href="#聚集索引非聚集索引">聚集索引、非聚集索引</a></li>
        <li><a href="#什么情形下索引失效">什么情形下索引失效</a></li>
        <li><a href="#数据库索引优化">数据库索引优化</a></li>
        <li><a href="#如何排查mysql中的慢查询">如何排查MySQL中的慢查询</a></li>
      </ul>
    </li>
    <li><a href="#操作系统">操作系统</a>
      <ul>
        <li><a href="#linux常用命令">Linux常用命令</a></li>
        <li><a href="#进程和线程有什么区别">进程和线程有什么区别</a></li>
      </ul>
    </li>
    <li><a href="#nginx">Nginx</a></li>
    <li><a href="#网络">网络</a>
      <ul>
        <li><a href="#ip是什么">IP是什么？</a></li>
        <li><a href="#1921680116-是什么意思">192.168.0.1/16 是什么意思？</a></li>
        <li><a href="#ipv4-与-ipv6-区别">IPv4 与 IPv6 区别</a></li>
        <li><a href="#dns-主要作用是什么">DNS 主要作用是什么？</a></li>
        <li><a href="#dns工作原理">DNS工作原理</a></li>
        <li><a href="#dns负载均衡策略">DNS负载均衡策略</a></li>
        <li><a href="#分布式环境下-session-如何处理">分布式环境下 Session 如何处理？</a></li>
        <li><a href="#从浏览器地址栏输入-url-到显示主页的过程发生了什么">从浏览器地址栏输入 URL 到显示主页的过程发生了什么？</a></li>
        <li><a href="#tcp-和-udp-的区别">TCP 和 UDP 的区别</a></li>
        <li><a href="#http和https有什么区别">HTTP和HTTPS有什么区别？</a></li>
        <li><a href="#get和post有什么区别">GET和POST有什么区别</a></li>
        <li><a href="#http状态码">HTTP状态码</a></li>
        <li><a href="#常用端口">常用端口</a></li>
        <li><a href="#cookie和session的区别">Cookie和Session的区别</a></li>
        <li><a href="#cgifastcgiphp-fpm">CGI、FastCGI、PHP-FPM</a></li>
        <li><a href="#php-fpmnginx通信原理">PHP-FPM+NGINX通信原理</a></li>
      </ul>
    </li>
    <li><a href="#nosql">NoSQL</a>
      <ul>
        <li></li>
        <li><a href="#redis">Redis</a></li>
        <li><a href="#redis持久化">Redis持久化</a></li>
        <li><a href="#1-rdb-持久化">1. RDB 持久化：</a></li>
        <li><a href="#2-aof-持久化">2. AOF 持久化：</a></li>
        <li><a href="#持久化选择和使用场景">持久化选择和使用场景：</a></li>
        <li><a href="#rdb-和-aof恢复优先级对比">RDB 和 AOF恢复优先级对比</a></li>
        <li><a href="#redismemcache-和mongodb-的区别">Redis、Memcache 和、MongoDB 的区别</a></li>
      </ul>
    </li>
    <li><a href="#设计模式">设计模式</a>
      <ul>
        <li><a href="#工厂模式">工厂模式</a></li>
        <li><a href="#单例模式">单例模式</a></li>
        <li><a href="#模板方法模">模板方法模</a></li>
        <li><a href="#策略模式">策略模式</a></li>
        <li><a href="#适配器模式">适配器模式</a></li>
        <li><a href="#代理模式">代理模式</a></li>
        <li><a href="#装饰者模式">装饰者模式</a></li>
        <li><a href="#外观模式">外观模式</a></li>
      </ul>
    </li>
    <li><a href="#其他">其他</a>
      <ul>
        <li><a href="#elasticsearch">Elasticsearch</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </aside>
        
    </div><script>
    
        let button = document.getElementById('tocButton');
        let hide = document.getElementById("hide");
        let contents=document.getElementById("contents");
        button.addEventListener("click", function() {
        if (hide.style.display!='block') {
            hide.style.display='block'
        } else {
            hide.style.display='none'
            contents.style.color='rgb(96, 134, 180)'
        }
        });
    




</script>
            </div>
            <h2 id="php">PHP</h2>
<h4 id="include和require的区别">include和require的区别</h4>
<p>1.include 引入文件的时候，如果碰到错误，会给出提示，并继续运行下边的代码。require 引入文件的时候，如果碰到错误，会给出提示，并停止运行下边的代码。<br>
2.include() 执行时需要引用的文件每次都要进行读取和评估，require() 执行时需要引用的文件只处理一次（实际上执行时需要引用的文件内容替换了 require() 语句）可以看出若有包含这些指令之一的代码和可能执行多次的代码，则使用 require() 效率比较高，若每次执行代码时相读取不同的文件或者有通过一组文件叠代的循环，就使用 include()，可以给想要包括的文件名设置变量，当参数为 include() 时使用这个变量。<br>
3.incluce 在用到时加载；require 在一开始就加载；_once 后缀表示已加载的不加载。</p>
<h4 id="预定义变量">预定义变量</h4>
<p>$GLOBALS — 引用全局作用域中可用的全部变量<br>
$_SERVER — 服务器和执行环境信息<br>
$_GET — HTTP GET 变量<br>
$_POST — HTTP POST 变量<br>
$_FILES — HTTP 文件上传变量<br>
$_REQUEST — HTTP Request 变量<br>
$_SESSION — Session 变量<br>
$_ENV — 环境变量<br>
$_COOKIE — HTTP Cookies<br>
$php_errormsg — 前一个错误信息<br>
$http_response_header — HTTP 响应头<br>
$argc — 传递给脚本的参数数目<br>
$argv — 传递给脚本的参数数组<br>
<a href="https://www.php.net/manual/zh/reserved.variables.php">官方文档</a></p>
<h4 id="使用-php-函数对变量-x-进行比较">使用 PHP 函数对变量 $x 进行比较</h4>
<p><a href="https://www.php.net/manual/zh/types.comparisons.php">types.comparisons.php</a></p>
<h3 id="php支持多线程吗">PHP支持多线程吗？</h3>
<p>PHP 本身的标准版本并不直接支持真正的多线程。PHP 的主要运行模型是基于请求-响应的，每个请求都在一个独立的进程中处理。在这个模型下，PHP 是单线程运行的，每个请求都有自己的上下文，不共享数据。</p>
<p>然而，PHP 提供了一些扩展和库，以支持并发编程或者异步操作，使得可以在某种程度上模拟多线程的效果。以下是一些与并发和异步相关的 PHP 扩展和库：</p>
<ul>
<li><strong>Swoole：</strong> 是一个基于 C 语言开发的高性能异步、协程并发网络通信引擎。Swoole 提供了协程和异步 I/O 支持，可以用于编写高并发的服务器程序。</li>
</ul>
<p>虽然上述方法可以用于处理并发任务，但需要注意的是，PHP 不是为真正的多线程编程而设计的。对于需要更严格的多线程控制和共享内存等需求，其他语言如 Java 或 C++ 更为适用。</p>
<h2 id="编程基础">编程基础</h2>
<h3 id="什么是aop面向切面编程">什么是AOP面向切面编程</h3>
<p>&ldquo;AOP&rdquo; 代表的是 &ldquo;Aspect-Oriented Programming&rdquo;，即面向切面编程。AOP 是一种编程范式，旨在通过分离关注点（concerns）来提高代码的模块化性和可维护性。</p>
<p>在传统的面向对象编程（OOP）中，程序的功能通常被划分为各个类，每个类负责一个特定的功能。然而，有时一些横切关注点（cross-cutting concerns）会横穿多个类，例如日志记录、性能监控、事务管理等。AOP 的目标是通过在这些关注点上划定切面（Aspect），从而将其与主要业务逻辑分开，提高代码的模块化程度。</p>
<p>关键概念和术语：</p>
<ol>
<li>
<p><strong>Aspect（切面）：</strong> 一个横切关注点的模块。它定义了在程序中的哪个地方（切点）以及如何（通知）执行横切关注点的逻辑。</p>
</li>
<li>
<p><strong>Join Point（连接点）：</strong> 在程序执行过程中可能被切面拦截的点。通常是方法调用、异常抛出或字段访问等。</p>
</li>
<li>
<p><strong>Advice（通知）：</strong> 切面在连接点执行的代码。通知包括 &ldquo;before&rdquo;（前置通知，事前执行）、&ldquo;after&rdquo;（后置通知，事后执行）、&ldquo;around&rdquo;（环绕通知，可以在连接点前后自定义操作）等。</p>
</li>
<li>
<p><strong>Pointcut（切点）：</strong> 定义了连接点的集合，使切面知道在何处执行通知。</p>
</li>
</ol>
<p>AOP 提供了一种在不改变主要业务逻辑的情况下，将横切关注点模块化的方式。这有助于提高代码的可维护性、可重用性，并降低了代码中的重复性。通过使用 AOP，程序员可以更好地管理横切关注点，而无需将这些关注点散布在整个代码库中。</p>
<h3 id="雪花算法">雪花算法</h3>
<p>雪花算法（Snowflake Algorithm）是一种用于生成全局唯一标识符（UUID）的分布式系统中的算法。它最初由Twitter开发，用于生成分布式系统中的唯一ID，以确保在不同的节点和不同的时间生成的ID都是唯一的。</p>
<p>雪花算法的ID结构通常包含64位，按照特定的位数分布，具体如下：</p>
<ul>
<li>1位标识位（固定为0，表示正数）</li>
<li>41位时间戳（精确到毫秒级，可以支持69年的时间）</li>
<li>10位机器标识（用来表示不同的机器，可以部署在2^10台机器上）</li>
<li>12位序列号（每台机器每毫秒可以生成2^12个ID）</li>
</ul>
<p>雪花算法的生成过程如下：</p>
<ol>
<li>获取当前时间戳，41位。</li>
<li>获取机器标识，10位。</li>
<li>获取序列号，12位。</li>
<li>将它们组合成64位的ID。</li>
</ol>
<p>需要注意的是，雪花算法依赖于系统时钟，因此如果系统时钟发生回退，可能会导致生成的ID不是严格递增的。为了解决这个问题，一般建议在系统中配置时钟同步服务。</p>
<p>雪花算法通过合理分配各部分的位数，保证了在同一时刻、同一机器上生成的ID是唯一的，同时在分布式环境中生成的ID也尽可能保持有序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Snowflake</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> $epoch <span style="color:#f92672">=</span> <span style="color:#ae81ff">1625097600000</span>; <span style="color:#75715e">// 起始时间戳，这里设置为2021-07-01 00:00:00的毫秒表示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> $machineId;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> $sequence <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> $machineIdBits <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> $sequenceBits <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> $maxMachineId;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> $maxSequence;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> __construct($machineId) {
</span></span><span style="display:flex;"><span>        $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">maxMachineId</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">^</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">machineIdBits</span>);
</span></span><span style="display:flex;"><span>        $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">maxSequence</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">^</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">sequenceBits</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ($machineId <span style="color:#f92672">&gt;</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">maxMachineId</span> <span style="color:#f92672">||</span> $machineId <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Exception</span>(<span style="color:#e6db74">&#34;Invalid machine ID&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">machineId</span> <span style="color:#f92672">=</span> $machineId;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">generateId</span>() {
</span></span><span style="display:flex;"><span>        $currentTimestamp <span style="color:#f92672">=</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getTimestamp</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ($currentTimestamp <span style="color:#f92672">&lt;</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">lastTimestamp</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Exception</span>(<span style="color:#e6db74">&#34;Clock moved backwards. Refusing to generate ID&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ($currentTimestamp <span style="color:#f92672">==</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">lastTimestamp</span>) {
</span></span><span style="display:flex;"><span>            $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">sequence</span> <span style="color:#f92672">=</span> ($this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">sequence</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">maxSequence</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ($this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">sequence</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                $currentTimestamp <span style="color:#f92672">=</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">waitNextMillis</span>($this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">lastTimestamp</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">sequence</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">lastTimestamp</span> <span style="color:#f92672">=</span> $currentTimestamp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        $id <span style="color:#f92672">=</span> (($currentTimestamp <span style="color:#f92672">-</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">epoch</span>) <span style="color:#f92672">&lt;&lt;</span> ($this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">machineIdBits</span> <span style="color:#f92672">+</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">sequenceBits</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">|</span> ($this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">machineId</span> <span style="color:#f92672">&lt;&lt;</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">sequenceBits</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">|</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">sequence</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> $id;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getTimestamp</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">round</span>(<span style="color:#a6e22e">microtime</span>(<span style="color:#66d9ef">true</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">waitNextMillis</span>($lastTimestamp) {
</span></span><span style="display:flex;"><span>        $timestamp <span style="color:#f92672">=</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getTimestamp</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> ($timestamp <span style="color:#f92672">&lt;=</span> $lastTimestamp) {
</span></span><span style="display:flex;"><span>            $timestamp <span style="color:#f92672">=</span> $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getTimestamp</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> $timestamp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 示例使用，创建一个机器ID为1的Snowflake对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>$snowflake <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Snowflake</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 生成ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>$id <span style="color:#f92672">=</span> $snowflake<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">generateId</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出生成的ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">echo</span> $id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">?&gt;</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><h2 id="mysql">MySQL</h2>
<h3 id="三范式">三范式</h3>
<p>数据库的三范式是关系型数据库设计中的一组规范，用于确保数据库中的数据结构合理、有效、减少冗余。这三个范式是：</p>
<ol>
<li>
<p><strong>第一范式（1NF）：</strong> 数据表中的每一列都是不可再分的原子数据项。换句话说，表中的每个字段必须是单一值，而不能是一组值或是可再分的值。确保每列的原子性。</p>
<p>例如，一个包含学生姓名和其课程的表：</p>
<table>
<thead>
<tr>
<th>学生姓名</th>
<th>所修课程</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>数学, 物理, 化学</td>
</tr>
</tbody>
</table>
<p>不符合第一范式，应该拆分为两个表。</p>
</li>
<li>
<p><strong>第二范式（2NF）：</strong> 在满足第一范式的基础上，表中的非主键列（非主键属性）完全依赖于整个主键。换句话说，每个非主键列都必须完全依赖于表的主键。</p>
<p>例如，一个包含学生课程成绩的表：</p>
<table>
<thead>
<tr>
<th>学生ID</th>
<th>课程</th>
<th>教师</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>数学</td>
<td>张老师</td>
<td>90</td>
</tr>
<tr>
<td>1</td>
<td>物理</td>
<td>王老师</td>
<td>85</td>
</tr>
</tbody>
</table>
<p>这个表不符合第二范式，应该拆分成两个表，分别存储学生课程信息和成绩信息。</p>
</li>
<li>
<p><strong>第三范式（3NF）：</strong> 在满足第二范式的基础上，任何非主键列都不传递依赖于主键。换句话说，表中的每个非主键列都直接依赖于主键，而不是依赖于其他非主键列。</p>
<p>例如，一个包含学生地址和学生所在城市的表：</p>
<table>
<thead>
<tr>
<th>学生ID</th>
<th>学生姓名</th>
<th>学生地址</th>
<th>所在城市</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>小明</td>
<td>123 Main St</td>
<td>Beijing</td>
</tr>
</tbody>
</table>
<p>这个表不符合第三范式，应该将学生地址和所在城市拆分成两个表，以避免传递依赖。</p>
</li>
</ol>
<p>遵循三范式有助于设计更规范、减少冗余、易于维护的数据库结构。然而，有时为了性能或其他需求，可能会选择违反三范式的原则。在设计数据库时，需要权衡三范式的优势和具体应用场景的需求。</p>
<h3 id="innodb和myisam">InnoDB和MyISAM</h3>
<p>InnoDB和MyISAM是MySQL数据库两种常见的存储引擎，它们在设计、性能特性和适用场景上有一些区别：</p>
<ol>
<li>
<p><strong>事务支持：</strong></p>
<ul>
<li><strong>InnoDB：</strong> 支持事务（ACID兼容），可以提供较高的并发性和数据完整性。适用于需要事务支持的应用，如银行系统、订单处理系统等。</li>
<li><strong>MyISAM：</strong> 不支持事务，只支持表级别的锁，对并发性能的支持相对较弱。适用于读操作较多、写操作较少的简单应用。</li>
</ul>
</li>
<li>
<p><strong>锁级别：</strong></p>
<ul>
<li><strong>InnoDB：</strong> 支持行级锁定，允许多个事务同时操作不同行。这有助于提高并发性，减少锁冲突。</li>
<li><strong>MyISAM：</strong> 只支持表级锁定，当一个事务对表进行写操作时，其他事务无法同时对同一表进行写操作，可能会导致锁冲突和性能下降。</li>
</ul>
</li>
<li>
<p><strong>崩溃恢复：</strong></p>
<ul>
<li><strong>InnoDB：</strong> 支持崩溃恢复，具有更好的容错性。在数据库发生崩溃时，InnoDB可以通过日志文件来进行恢复，保持数据的一致性。</li>
<li><strong>MyISAM：</strong> 对崩溃恢复的支持相对较弱，容易出现损坏的情况。在发生崩溃时，可能需要手动修复表。</li>
</ul>
</li>
<li>
<p><strong>外键约束：</strong></p>
<ul>
<li><strong>InnoDB：</strong> 支持外键约束，保证数据的完整性。可以通过定义外键来建立表与表之间的关联。</li>
<li><strong>MyISAM：</strong> 不支持外键约束，需要在应用层面来保证数据的一致性。</li>
</ul>
</li>
<li>
<p><strong>全文索引：</strong></p>
<ul>
<li><strong>InnoDB：</strong> 支持全文索引，可以用于实现全文搜索。</li>
<li><strong>MyISAM：</strong> 也支持全文索引，并在某些情况下可能比InnoDB更快。</li>
</ul>
</li>
<li>
<p><strong>表空间和缓存：</strong></p>
<ul>
<li><strong>InnoDB：</strong> 支持表空间，表数据和索引存储在相同的文件中。使用缓冲池来缓存数据和索引，支持自动调整。</li>
<li><strong>MyISAM：</strong> 不支持表空间，表数据和索引分开存储。使用键缓存来缓存索引，使用操作系统的缓存来缓存数据。</li>
</ul>
</li>
<li>
<p><strong>自增主键：</strong></p>
<ul>
<li><strong>InnoDB：</strong> 自增主键是在表的聚簇索引上实现的，因此表的物理顺序与主键的顺序一致。</li>
<li><strong>MyISAM：</strong> 自增主键的实现是在一个独立的文件上，不直接影响表的物理顺序。</li>
</ul>
</li>
</ol>
<p>根据应用需求和性能特点，选择合适的存储引擎是很重要的。通常，对于需要事务支持、并发性能高以及容错性好的应用，InnoDB是更好的选择；而对于读操作较多、写操作较少、对事务支持要求不高的应用，MyISAM可能是一个合适的选择。</p>
<h3 id="事务的特征">事务的特征</h3>
<p>事务是数据库管理系统中用来管理对数据库的访问和更新的一个操作单元。事务应该具备四个基本特性，通常被称为ACID特性：</p>
<ol>
<li>
<p><strong>原子性（Atomicity）：</strong> 原子性要求事务是一个不可分割的最小工作单元，要么完全执行，要么完全不执行。如果事务的所有操作都成功完成，则事务被认为是原子的；如果任何一个操作失败，则整个事务应该被回滚到初始状态，以确保数据的一致性。</p>
</li>
<li>
<p><strong>一致性（Consistency）：</strong> 一致性确保事务将数据库从一种一致性状态转移到另一种一致性状态。在事务执行前后，数据库应该保持一致性，即事务的执行不会破坏数据库的完整性约束。如果一个事务执行完毕后，数据库不再保持一致性，系统会回滚事务，使数据恢复到事务开始前的状态。</p>
</li>
<li>
<p><strong>隔离性（Isolation）：</strong> 隔离性要求一个事务的执行不能被其他事务干扰。即使多个事务并发执行，每个事务都应该认为它在独立地操作数据。这可以通过使用锁或其他并发控制机制来实现，以防止不同事务之间的相互影响。</p>
</li>
<li>
<p><strong>持久性（Durability）：</strong> 持久性确保一旦事务被提交，其结果就是永久性的，即使系统发生故障也不会丢失。一旦事务成功提交，对数据库的修改应该永久保存在数据库中，以便在系统故障后能够恢复。</p>
</li>
</ol>
<p>这些ACID特性确保了数据库事务的可靠性和一致性。在设计和执行数据库操作时，开发人员和数据库管理员需要特别关注这些特性，以确保数据的正确性和系统的稳定性。</p>
<h3 id="数据库事务隔离级别">数据库事务隔离级别</h3>
<blockquote>
<p>MySQL的默认隔离级别是REPEATABLE READ（可重复读）</p>
</blockquote>
<p>数据库事务隔离级别是指在并发执行的多个事务中，一个事务对数据库中数据的修改在其他事务看来是隔离的程度。数据库管理系统定义了多个隔离级别，以平衡并发性能和数据一致性之间的关系。主要的事务隔离级别包括：</p>
<ol>
<li>
<p><strong>读未提交（Read Uncommitted）：</strong></p>
<ul>
<li>允许一个事务读取另一个事务未提交的数据。</li>
<li>最低的隔离级别，可能导致脏读（读取到未提交的数据）、不可重复读和幻读。</li>
</ul>
</li>
<li>
<p><strong>读已提交（Read Committed）：</strong></p>
<ul>
<li>保证一个事务不会读取到另一个未提交事务的数据。</li>
<li>避免了脏读，但仍可能存在不可重复读和幻读问题。</li>
</ul>
</li>
<li>
<p><strong>可重复读（Repeatable Read）：</strong></p>
<ul>
<li>保证在同一事务中多次读取相同数据时，得到的结果是一致的。</li>
<li>避免了脏读和不可重复读，但仍可能存在幻读问题。</li>
</ul>
</li>
<li>
<p><strong>串行化（Serializable）：</strong></p>
<ul>
<li>最高的隔离级别，确保事务之间完全隔离，不会发生脏读、不可重复读和幻读。</li>
<li>通过对数据加锁来实现，可能导致并发性能下降。</li>
</ul>
</li>
</ol>
<p>在实际应用中，可以根据业务需求和性能要求选择适当的事务隔离级别。更高的隔离级别通常会带来更多的锁和资源消耗，降低并发性能，因此需要权衡。对于一些特定的业务场景，可以使用数据库提供的特定机制来解决特定的并发问题，而不是仅仅依赖隔离级别。例如，使用行级锁、表级锁或乐观锁等。</p>
<blockquote>
<p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系</a></p>
</blockquote>
<h3 id="数据库事务隔离级别相关的并发问题">数据库事务隔离级别相关的并发问题</h3>
<p>与数据库事务隔离级别相关的并发问题主要包括脏读、不可重复读和幻读。这些问题是由于多个事务同时访问和修改数据库时可能发生的情况，而不同的隔离级别会在处理这些问题上有不同的策略。</p>
<ol>
<li>
<p><strong>脏读（Dirty Read）：</strong></p>
<ul>
<li><strong>定义：</strong> 一个事务读取了另一个事务未提交的数据。</li>
<li><strong>影响隔离级别：</strong> 读未提交（Read Uncommitted）隔离级别可能导致脏读。</li>
<li><strong>解决方案：</strong> 提高隔离级别至读已提交（Read Committed）及以上，以避免脏读问题。</li>
</ul>
</li>
<li>
<p><strong>不可重复读（Non-repeatable Read）：</strong></p>
<ul>
<li><strong>定义：</strong> 在一个事务中，两次读取同一行数据时得到了不同的结果，因为在两次读取之间有另一个事务修改了该行数据。</li>
<li><strong>影响隔离级别：</strong> 读已提交（Read Committed）隔离级别可能导致不可重复读。</li>
<li><strong>解决方案：</strong> 提高隔离级别至可重复读（Repeatable Read）及以上，通过锁定读取的数据来防止其他事务的修改。</li>
</ul>
</li>
<li>
<p><strong>幻读（Phantom Read）：</strong></p>
<ul>
<li><strong>定义：</strong> 一个事务在读取了一组数据后，又发现了另一个事务插入了一些新的数据，导致第一次读取和第二次读取得到的数据集不一致。</li>
<li><strong>影响隔离级别：</strong> 可重复读（Repeatable Read）隔离级别可能导致幻读。</li>
<li><strong>解决方案：</strong> 提高隔离级别至串行化（Serializable），通过更强的锁定机制来防止其他事务的插入或删除操作。</li>
</ul>
</li>
</ol>
<p>不同的隔离级别提供了不同的权衡方案，高隔离级别通常可以解决并发问题，但可能会带来性能的降低。在选择隔离级别时，需要根据应用的特定需求和对并发问题的容忍程度做出权衡。</p>
<h3 id="什么是mvcc">什么是MVCC</h3>
<p>MVCC（Multi-Version Concurrency Control）是一种数据库并发控制的机制，旨在解决在多个事务同时访问数据库时可能发生的并发问题，包括脏读、不可重复读和幻读等。MVCC通过维护多个版本的数据，使得每个事务看到的数据是一个&quot;快照&quot;，从而提供了更高的并发性和事务隔离性。</p>
<p>MVCC的实现通常包括以下关键概念：</p>
<ol>
<li>
<p><strong>版本号：</strong></p>
<ul>
<li>每个数据行都会有一个版本号或者时间戳，用于标识该数据行的版本。版本号可以是一个递增的整数，也可以是一个时间戳。</li>
</ul>
</li>
<li>
<p><strong>Read View（读视图）：</strong></p>
<ul>
<li>每个事务在启动时都会创建一个Read View，该视图包含了在该事务开始之前已经提交的事务的版本信息。</li>
<li>Read View定义了事务能够看到的数据版本，包括已提交事务的版本以及当前事务自身的修改。</li>
</ul>
</li>
<li>
<p><strong>Undo Log（回滚日志）：</strong></p>
<ul>
<li>当一个事务更新一条记录时，数据库会在Undo Log中保存该记录的一个旧版本。这个旧版本的数据对于其他并发事务是可见的。</li>
<li>如果事务需要回滚，可以使用Undo Log来撤销该事务对数据的修改。</li>
</ul>
</li>
<li>
<p><strong>读操作：</strong></p>
<ul>
<li>当事务执行读操作时，会根据自己的Read View，查找符合条件的已提交事务的数据版本，确保事务看到的是在它开始之前已经提交的数据。</li>
<li>如果读取的数据版本比事务的Read View的范围要新，则会使用Undo Log来获取旧版本的数据。</li>
</ul>
</li>
<li>
<p><strong>写操作：</strong></p>
<ul>
<li>当事务执行写操作时，会将修改的数据写入一个新的版本，并将旧版本的数据保存到Undo Log中。其他事务仍然可以读取旧版本的数据。</li>
<li>写操作的版本号通常会递增，确保新版本的数据在数据库中成为最新的数据。</li>
</ul>
</li>
<li>
<p><strong>提交：</strong></p>
<ul>
<li>当事务提交时，它的修改变成了其他事务的可见版本，并且新版本的数据在数据库中成为最新的数据。</li>
</ul>
</li>
</ol>
<p>MVCC的优势在于提高了数据库的并发性能，多个事务可以并发地读取和修改数据，而不会出现数据一致性问题。MVCC被广泛用于支持数据库的各种隔离级别，如可重复读和读已提交。主流的关系型数据库，如MySQL、PostgreSQL等，都采用了MVCC机制。</p>
<h3 id="mysql的可重复读隔离级别是如何解决幻读的">MySQL的可重复读隔离级别是如何解决幻读的</h3>
<p>在MySQL的可重复读（REPEATABLE READ）隔离级别下，通过多版本并发控制（MVCC，Multi-Version Concurrency Control）机制来解决幻读问题。MVCC使得每个事务看到的数据是一个&quot;快照&quot;，并且不会受到其他并发事务的影响。</p>
<p>解决幻读问题的主要方法是通过在事务中读取的数据上加锁，防止其他事务插入或删除与读取操作相关的数据。以下是MVCC是如何实现的：</p>
<ol>
<li>
<p><strong>Read View（读视图）：</strong></p>
<ul>
<li>在可重复读隔离级别下，每个事务启动时都会创建一个Read View，用于表示事务开始时数据库的状态。这个Read View包含了所有在该事务开始之前已经提交的事务对数据的影响。</li>
</ul>
</li>
<li>
<p><strong>Undo Log（回滚日志）：</strong></p>
<ul>
<li>当一个事务更新一条记录时，MySQL会在Undo Log中保存该记录的一个旧版本。这样，其他事务在查询时，即使有其他事务在更新，也可以读取到旧版本的数据。</li>
</ul>
</li>
<li>
<p><strong>Read View的生成和使用：</strong></p>
<ul>
<li>在可重复读隔离级别下，事务在启动时会生成一个Read View，用于表示事务开始时的数据库状态。这个Read View包含了所有已提交的事务对数据的影响。</li>
<li>当一个事务执行查询时，只会看到在它开始时已经提交的事务对数据的影响，不会看到其他事务在它开始之后提交的事务的影响。</li>
<li>当事务中的查询操作涉及到范围查询时，Read View还会对查询的范围进行锁定，防止其他事务在该范围内插入或删除数据。</li>
</ul>
</li>
</ol>
<p>通过这种方式，可重复读隔离级别可以避免幻读问题。即使在一个事务中执行范围查询，在该事务内的其他事务插入新数据也不会被当前事务看到，因为Read View锁定了查询范围。这种机制确保了事务在可重复读隔离级别下的一致性和隔离性。</p>
<h3 id="mysql-有哪些锁">MySQL 有哪些锁？</h3>
<p>如果按锁粒度划分，有以下 3 种：</p>
<ul>
<li>表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低；不会出现死锁。</li>
<li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</li>
<li>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。</li>
</ul>
<p>如果按照兼容性，有 2 种：</p>
<ul>
<li>共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。</li>
<li>排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。</li>
</ul>
<h3 id="mysql索引数据结构">MySQL索引数据结构</h3>
<p>MySQL 索引的数据结构主要有以下几种：</p>
<ol>
<li>
<p><strong>B树（或B+树）索引：</strong></p>
<ul>
<li><strong>B树：</strong> 平衡树结构，包含根节点、内部节点和叶子节点。每个节点包含多个键值对，按照键值大小有序排列。</li>
<li><strong>B+树：</strong> 在B树的基础上做了优化，将数据只存储在叶子节点，而内部节点只存储键值和指向子节点的指针。叶子节点通过链表连接，形成有序的叶子节点序列。</li>
<li><strong>特点：</strong> B+树适用于范围查询，因为叶子节点是有序的，范围查询只需要遍历叶子节点链表即可。B+树的叶子节点包含了完整的键值信息，适合做范围查询和顺序遍历。</li>
<li><strong>适用场景：</strong> 大多数数据库引擎（如InnoDB）使用B+树索引结构。</li>
</ul>
</li>
<li>
<p><strong>哈希索引：</strong></p>
<ul>
<li><strong>特点：</strong> 哈希索引是通过哈希函数计算键值的哈希值，然后在哈希表中直接查找。哈希索引适用于等值查询，即通过哈希值直接定位到具体的记录。</li>
<li><strong>优点：</strong> 哈希索引查询速度非常快，对于等值查询非常高效。</li>
<li><strong>缺点：</strong> 不支持范围查询，也不适用于排序和顺序遍历。哈希碰撞（多个键值映射到相同的哈希值）可能导致性能下降。</li>
<li><strong>适用场景：</strong> 适合于主键等值查询，不适合需要范围查询或顺序遍历的场景。</li>
</ul>
</li>
<li>
<p><strong>全文索引：</strong></p>
<ul>
<li><strong>特点：</strong> 全文索引用于对文本数据进行全文搜索，提供更复杂的搜索能力。MySQL中常用的全文索引是基于倒排索引实现的，它包含了文本中的关键词及其出现位置。</li>
<li><strong>适用场景：</strong> 适用于需要进行全文搜索的场景，如文章搜索、博客系统等。</li>
</ul>
</li>
</ol>
<p>在实际应用中，选择合适的索引类型取决于具体的查询需求。通常，对于大多数场景，B+树索引是一个较为通用和高效的选择，而哈希索引适用于特定的等值查询场景。全文索引则用于需要进行全文搜索的情况。</p>
<h3 id="聚集索引非聚集索引">聚集索引、非聚集索引</h3>
<p>聚集索引和非聚集索引是数据库中两种不同的索引组织方式。它们影响着数据在磁盘上的存储结构和检索方式。</p>
<ol>
<li>
<p><strong>聚集索引（Clustered Index）</strong>：</p>
<ul>
<li>聚集索引决定了数据表中行的物理存储顺序，并且整个表的数据按照聚集索引的顺序进行存储。一张表只能有一个聚集索引。</li>
<li>当表有聚集索引时，数据行按照聚集索引的排序方式存储在磁盘上，而聚集索引本身也是表的一部分，即数据行和聚集索引共享相同的存储空间。</li>
<li>常见的例子是在SQL Server中，主键约束默认就是一个聚集索引。</li>
</ul>
</li>
<li>
<p><strong>非聚集索引（Non-Clustered Index）</strong>：</p>
<ul>
<li>非聚集索引是独立于实际数据存储顺序的索引结构。一张表可以有多个非聚集索引。</li>
<li>非聚集索引包含索引的键值和一个指向实际数据行的指针或者位置信息。查询时通过非聚集索引定位到数据行，然后再根据指针或位置信息获取实际数据。</li>
<li>非聚集索引的存在使得可以根据不同的列创建多个索引，提高检索的灵活性。但由于需要额外的指针或位置信息，可能会导致相对较大的存储开销。</li>
</ul>
</li>
</ol>
<p>总体而言，聚集索引和非聚集索引在数据库设计和性能方面有不同的权衡。聚集索引适合那些经常需要按照某个顺序访问数据的情况，而非聚集索引适合提高灵活性，允许通过多个列进行检索。在具体的数据库系统中，实现方式和性能表现可能会有所不同。</p>
<h3 id="什么情形下索引失效">什么情形下索引失效</h3>
<p>索引在数据库中的目的是提高查询性能，但在一些情况下，索引可能会失效，导致无法充分利用索引的优势。以下是一些导致索引失效的常见情形：</p>
<ol>
<li>
<p><strong>使用函数或运算符</strong>：</p>
<ul>
<li>当在查询中对索引列使用函数或运算符时，索引可能会失效。例如，<code>WHERE LOWER(column_name) = 'value'</code>或<code>WHERE column_name + 10 = 20</code>。</li>
</ul>
</li>
<li>
<p><strong>不满足最左前缀原则</strong>：</p>
<ul>
<li>如果索引是复合索引（包含多个列），则查询时必须按照索引的最左前缀列开始，否则索引可能失效。例如，索引是 <code>(column1, column2)</code>，查询条件中如果只使用了 <code>column2</code> 而没有使用 <code>column1</code>，那么索引可能无法生效。</li>
</ul>
</li>
<li>
<p><strong>隐式数据类型转换</strong>：</p>
<ul>
<li>当查询中对索引列进行了隐式的数据类型转换时，索引可能失效。例如，索引是整数类型，但查询时对该列进行了字符型的比较。</li>
</ul>
</li>
<li>
<p><strong>使用通配符在索引列开头</strong>：</p>
<ul>
<li>当使用通配符在索引列的开头进行模糊匹配时，索引可能失效。例如，<code>WHERE column_name LIKE '%value'</code>。</li>
</ul>
</li>
<li>
<p><strong>使用非SARGABLE条件</strong>：</p>
<ul>
<li>SARGABLE（Search ARGument ABLE）条件是指能够利用索引进行搜索的条件。如果使用了非SARGABLE的条件，例如在索引列上进行了计算，那么索引可能会失效。</li>
</ul>
</li>
<li>
<p><strong>列上存在 NULL 值</strong>：</p>
<ul>
<li>对于包含 NULL 值的列，查询时如果使用了 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 条件，可能导致索引失效。</li>
</ul>
</li>
<li>
<p><strong>统计信息不准确</strong>：</p>
<ul>
<li>数据库系统根据统计信息来生成查询计划。如果统计信息不准确，可能导致数据库系统选择不合适的查询计划，使得索引失效。</li>
</ul>
</li>
<li>
<p><strong>表被锁定</strong>：</p>
<ul>
<li>当表被锁定时，查询可能无法使用索引。例如，当表上存在写操作或者被其他事务锁定时。</li>
</ul>
</li>
</ol>
<p>要避免索引失效，可以通过正确设计索引、编写符合SARGABLE条件的查询、避免函数和运算符的使用等方式来提高索引的有效性。数据库系统的查询执行计划和性能分析工具可以帮助检测和解决索引失效的问题。</p>
<h3 id="数据库索引优化">数据库索引优化</h3>
<p>索引是提高数据库查询性能的重要手段之一。以下是一些常用的索引优化策略：</p>
<ol>
<li>
<p><strong>选择合适的索引：</strong></p>
<ul>
<li>根据查询语句的特点选择合适的索引，通常应考虑到查询中涉及的字段、表的大小、查询频率等因素。</li>
<li>在常用的查询条件上建立索引，但不要过度索引，因为每个索引都会占用额外的存储空间，并影响写操作的性能。</li>
</ul>
</li>
<li>
<p><strong>联合索引：</strong></p>
<ul>
<li>对于经常一起查询的列，可以考虑建立联合索引。联合索引的顺序很重要，应该根据查询的频率和使用率来选择合适的列顺序。</li>
</ul>
</li>
<li>
<p><strong>覆盖索引：</strong></p>
<ul>
<li>尽量使用覆盖索引，即索引中包含了查询所需的所有列。这样可以避免回表操作，提高查询性能。</li>
</ul>
</li>
<li>
<p><strong>避免在索引列上进行计算：</strong></p>
<ul>
<li>尽量避免在索引列上进行计算或函数操作，这样可以保证索引的有效使用。例如，避免在索引列上使用<code>WHERE YEAR(date_column) = 2022</code>，而直接使用<code>WHERE date_column BETWEEN '2022-01-01' AND '2022-12-31'</code>。</li>
</ul>
</li>
<li>
<p><strong>定期分析查询计划：</strong></p>
<ul>
<li>使用<code>EXPLAIN</code>语句来分析查询计划，查看MySQL执行查询时使用的索引和表的访问方式。通过分析查询计划，可以发现潜在的性能问题，并进行相应的优化。</li>
</ul>
</li>
<li>
<p><strong>避免使用通配符前缀：</strong></p>
<ul>
<li>避免在索引列上使用通配符前缀，例如<code>LIKE '%abc'</code>。通配符前缀会导致索引失效，应尽量避免使用。</li>
</ul>
</li>
<li>
<p><strong>定期优化表：</strong></p>
<ul>
<li>定期使用<code>OPTIMIZE TABLE</code>语句来优化表，重新组织表的物理存储结构，提高查询性能。</li>
</ul>
</li>
<li>
<p><strong>避免使用不等于（!=或&lt;&gt;）：</strong></p>
<ul>
<li>在查询条件中尽量避免使用不等于操作符，因为不等于操作符可能导致索引失效，影响查询性能。</li>
</ul>
</li>
<li>
<p><strong>使用合理的数据类型：</strong></p>
<ul>
<li>使用合适大小的数据类型，可以减小索引的大小，提高查询性能。</li>
</ul>
</li>
<li>
<p><strong>限制返回结果集大小：</strong></p>
<ul>
<li>在查询中使用<code>LIMIT</code>语句限制返回结果集的大小，尤其是在涉及大表的查询中，可以避免不必要的性能开销。</li>
</ul>
</li>
<li>
<p><strong>使用缓存和CDN：</strong></p>
<ul>
<li>对于一些静态数据，可以考虑使用缓存或CDN来减轻数据库的负担，提高访问速度。</li>
</ul>
</li>
</ol>
<p>综合使用这些索引优化策略，可以有效提高数据库查询性能。优化的具体方法和效果会根据数据库表的结构、数据分布和查询特点而有所不同。</p>
<h3 id="如何排查mysql中的慢查询">如何排查MySQL中的慢查询</h3>
<p>排查MySQL中的慢SQL通常需要使用一系列工具和方法来定位问题。以下是一些建议和步骤：</p>
<ol>
<li>
<p><strong>启用慢查询日志：</strong></p>
<ul>
<li>在MySQL配置文件中启用慢查询日志，设置合适的<code>long_query_time</code>参数，以定义执行时间超过多少秒的查询被认为是慢查询。慢查询日志记录了执行时间超过设定阈值的SQL语句。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ini" data-lang="ini"><span style="display:flex;"><span><span style="color:#a6e22e">slow_query_log</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">long_query_time</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slow_query_log_file</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/path/to/slow-query.log</span>
</span></span></code></pre></div></li>
<li>
<p><strong>分析慢查询日志：</strong></p>
<ul>
<li>使用工具如<code>mysqldumpslow</code>、<code>pt-query-digest</code>等来分析慢查询日志，识别执行时间较长的SQL语句。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mysqldumpslow /path/to/slow-query.log
</span></span></code></pre></div></li>
<li>
<p><strong>使用EXPLAIN分析查询计划：</strong></p>
<ul>
<li>使用<code>EXPLAIN</code>语句分析慢查询的查询计划，以了解MySQL是如何执行查询的。这可以帮助识别潜在的性能问题，例如是否使用了索引。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> your_table <span style="color:#66d9ef">WHERE</span> your_condition;
</span></span></code></pre></div></li>
<li>
<p><strong>检查索引：</strong></p>
<ul>
<li>确保查询涉及的字段上有合适的索引。使用<code>SHOW INDEX FROM your_table</code>查看表的索引情况，确保索引被正确使用。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">FROM</span> your_table;
</span></span></code></pre></div></li>
<li>
<p><strong>使用MySQL性能工具：</strong></p>
<ul>
<li>使用MySQL提供的性能工具，如<code>SHOW PROCESSLIST</code>、<code>SHOW ENGINE INNODB STATUS</code>等，来查看当前运行的SQL语句和系统状态。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> PROCESSLIST;
</span></span></code></pre></div></li>
<li>
<p><strong>分析表结构和查询语句：</strong></p>
<ul>
<li>审查表结构，确保数据类型、字段长度等设计合理。同时检查查询语句，尽量避免使用<code>SELECT *</code>，只选择需要的字段。</li>
</ul>
</li>
<li>
<p><strong>考虑数据库缓存：</strong></p>
<ul>
<li>MySQL有一个查询缓存机制，但在某些情况下可能会导致性能问题。通过检查<code>query_cache_size</code>和<code>query_cache_type</code>等相关参数来了解缓存的使用情况。</li>
</ul>
</li>
<li>
<p><strong>定期优化表：</strong></p>
<ul>
<li>使用<code>OPTIMIZE TABLE</code>语句来优化表，重新组织表的物理存储结构。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>OPTIMIZE <span style="color:#66d9ef">TABLE</span> your_table;
</span></span></code></pre></div></li>
<li>
<p><strong>数据库服务器硬件和资源：</strong></p>
<ul>
<li>确保数据库服务器的硬件资源足够，例如内存、磁盘和CPU。监控系统资源使用情况，确保不会出现资源瓶颈。</li>
</ul>
</li>
<li>
<p><strong>使用数据库性能分析工具：</strong></p>
<ul>
<li>使用第三方性能分析工具，如Percona Toolkit、pt-query-digest等，进行更深入的性能分析和优化。</li>
</ul>
</li>
</ol>
<p>通过以上步骤，可以逐步定位慢查询的原因，并采取相应的优化策略。</p>
<blockquote>
<p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></p>
</blockquote>
<h2 id="操作系统">操作系统</h2>
<h3 id="linux常用命令">Linux常用命令</h3>
<ul>
<li><code>ls</code>: 列出目录中的文件和子目录。</li>
<li><code>cd</code>: 切换当前工作目录。</li>
<li><code>pwd</code>: 显示当前工作目录的路径。</li>
<li><code>cp</code>: 复制文件或目录。</li>
<li><code>mv</code>: 移动或重命名文件或目录。</li>
<li><code>rm</code>: 删除文件或目录。</li>
<li><code>mkdir</code>: 创建新目录。</li>
<li><code>rmdir</code>: 删除空目录。</li>
<li><code>cat</code>: 查看或连接文件。</li>
<li><code>more/less</code>: 分屏显示文件内容，逐页查看。</li>
<li><code>head/tail</code>: 显示文件的开头或结尾部分。</li>
<li><code>touch</code>: 更新文件的访问和修改时间，或者创建新文件。</li>
<li><code>chmod</code>: 修改文件或目录的权限。</li>
<li><code>chown</code>: 修改文件或目录的所有者。</li>
<li><code>ps</code>: 显示当前运行的进程。</li>
<li><code>kill</code>: 终止进程。</li>
<li><code>df</code>: 显示磁盘空间使用情况。</li>
<li><code>du</code>: 显示文件和目录的磁盘使用情况。</li>
<li><code>top</code>: 实时显示系统资源使用情况。</li>
<li><code>grep</code>: 在文件中搜索指定模式。</li>
<li><code>ping</code>: 测试网络连接并测量往返时间。</li>
<li><code>tar</code>: 打包、压缩和解压文件。</li>
</ul>
<h3 id="进程和线程有什么区别">进程和线程有什么区别</h3>
<p>进程（Process）和线程（Thread）是操作系统中用于执行程序的两个基本概念，它们有一些重要的区别：</p>
<ol>
<li>
<p><strong>定义：</strong></p>
<ul>
<li><strong>进程：</strong> 一个独立的执行环境，包括程序、数据和系统资源。每个进程都有独立的内存空间，进程之间相互独立。</li>
<li><strong>线程：</strong> 在进程内部执行的轻量级执行单元。同一进程内的线程共享相同的内存空间和资源，可以更方便地进行通信。</li>
</ul>
</li>
<li>
<p><strong>资源占用：</strong></p>
<ul>
<li><strong>进程：</strong> 占用独立的内存空间和系统资源，相对较重量级。</li>
<li><strong>线程：</strong> 共享进程的内存空间，相对轻量级。</li>
</ul>
</li>
<li>
<p><strong>通信和同步：</strong></p>
<ul>
<li><strong>进程：</strong> 进程之间通信需要特殊机制，如管道、消息队列、共享内存等。同步需要使用进程同步机制，如信号量、互斥锁等。</li>
<li><strong>线程：</strong> 线程可以通过共享内存直接进行通信，同步相对容易，可以使用线程同步机制，如互斥锁、条件变量等。</li>
</ul>
</li>
<li>
<p><strong>切换开销：</strong></p>
<ul>
<li><strong>进程：</strong> 进程切换开销较大，需要保存和恢复整个进程的上下文。</li>
<li><strong>线程：</strong> 线程切换开销较小，因为线程共享相同的地址空间，只需保存和恢复寄存器、程序计数器等少量数据。</li>
</ul>
</li>
<li>
<p><strong>独立性：</strong></p>
<ul>
<li><strong>进程：</strong> 进程是相互独立的执行单元，一个进程的崩溃不会影响其他进程。</li>
<li><strong>线程：</strong> 线程共享相同的地址空间，一个线程的错误可能会影响整个进程，但不会影响其他进程。</li>
</ul>
</li>
<li>
<p><strong>创建和销毁：</strong></p>
<ul>
<li><strong>进程：</strong> 创建和销毁进程相对较慢，涉及资源的分配和释放。</li>
<li><strong>线程：</strong> 创建和销毁线程相对较快，因为它们共享相同的资源。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li><strong>进程：</strong> 适用于需要独立执行环境、数据隔离、稳定性较强的应用。</li>
<li><strong>线程：</strong> 适用于需要轻量级、资源共享、响应速度快的应用。</li>
</ul>
</li>
</ol>
<h2 id="nginx">Nginx</h2>
<h2 id="网络">网络</h2>
<h3 id="ip是什么">IP是什么？</h3>
<p>IP（Internet Protocol）是计算机网络中的一种协议，用于在互联网上识别和定位设备。IP地址是用来标识网络上的设备的，例如，IPv4地址通常以形如192.168.0.1的格式表示。</p>
<h3 id="1921680116-是什么意思">192.168.0.1/16 是什么意思？</h3>
<p>192.168.0.1/16 是一个表示IP地址和子网掩码的标记，用于表示一个IP地址范围。这个标记中的 &ldquo;192.168.0.1&rdquo; 是网络的起始地址，而 &ldquo;/16&rdquo; 表示网络的子网掩码，指定了网络部分有16位，因此IP地址的前16位是网络部分。在IPv4中，一个IP地址总共有32位，因此剩下的 32 - 16 = 16 位用于表示主机。这意味着在这个特定的网络中，可以有2^16个不同的主机地址。</p>
<h3 id="ipv4-与-ipv6-区别">IPv4 与 IPv6 区别</h3>
<p>ipv4和ipv6的区别本质在于它们的二进制表示位数，ipv4是用32位0/1序列来表示的，而ipv6使用128位0/1序列来表示的。 ipv4用32位，为了方便人类记录和阅读，我们通常将ipv4的32位0/1分成4段8位序列，并用10进制来表示每一段(这样，一段的范围就是0到255)，段与段之间以“.”分隔。在IPv6的设计过程中除了一劳永逸地解决了地址短缺问题以外，还考虑了在IPv4中解决不好的其它问题，主要有端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。</p>
<h3 id="dns-主要作用是什么">DNS 主要作用是什么？</h3>
<p>DNS 是域名系统 (Domain Name System) 的缩写，它是由解析器和域名服务器组成的，又名“域名解析服务器”.域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。其中域名必须对应一个IP地址，而IP地址不一定有域名.在Internet上域名与IP地址之间是一对一（或者多对一）的.</p>
<h3 id="dns工作原理">DNS工作原理</h3>
<p>过程：浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存 -&gt; IPS服务器缓存 -&gt; 根域名服务器缓存 -&gt; 顶级域名服务器
缓存 -&gt; 主域名服务器缓存。查到后会将结果缓存至本地系统。</p>
<h3 id="dns负载均衡策略">DNS负载均衡策略</h3>
<p>原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址，在应答 DNS 查询时，DNS 服务器对每个查询
将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上
去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。例如可以根据每台机器的负载
量，该机器离用户地理位置的距离等等。</p>
<h3 id="分布式环境下-session-如何处理">分布式环境下 Session 如何处理？</h3>
<p>分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的 Session。<br>
可以使用 Redis 等分布式缓存来存储 Session，在多台服务器之间共享。</p>
<h3 id="从浏览器地址栏输入-url-到显示主页的过程发生了什么">从浏览器地址栏输入 URL 到显示主页的过程发生了什么？</h3>
<ol>
<li>DNS解析：将域名解析为对应的 IP 地址<br>
1.1. DNS 查找过程：浏览器缓存、本地DNS路由缓存、DNS解析服务）<br>
1.2. DNS 解析服务：
<blockquote>
<p>1.2.1. 请求根服务器，返回顶级域名服务器<br>
1.2.2. 请求顶级域名服务器（例如 .com ），返回权威域名服务器<br>
1.2.3. 请求权威域名服务器（例如 baidu.com ），返回对应的 IP 地址</p>
</blockquote>
</li>
<li>TCP连接：与服务器进行三次握手，建立 TCP 连接</li>
<li>向服务器发送 HTTP(S) 请求</li>
<li>服务器处理请求，返回 HTTP(S) 响应</li>
<li>浏览器解析并渲染页面</li>
<li>断开连接：TCP四次挥手，连接结束</li>
</ol>
<h3 id="tcp-和-udp-的区别">TCP 和 UDP 的区别</h3>
<p>最根本区别：TCP 是面向连接，而 UDP 是无连接。</p>
<ul>
<li>UDP 传输不可靠。</li>
<li>TCP 采用字节流传输；UDP 采用数据段报文</li>
<li>UDP 传输效率比 TCP 快</li>
<li>UDP 所需资源比 TCP 少</li>
<li>TCP 主要应用场景：文件传输、邮件传输；UDP 主要应用场景：即时通讯、域名转换</li>
<li>TCP 首部字节 20-60；UDP 首部 8 字节<br>
简单总结一下：UDP协议是无连接方式的协议，它的效率高，速度快，占资源少，对服务器的压力比较
小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。</li>
</ul>
<h3 id="http和https有什么区别">HTTP和HTTPS有什么区别？</h3>
<p>HTTP（HyperText Transfer Protocol）和HTTPS（HyperText Transfer Protocol Secure）是用于在客户端和服务器之间传输数据的两种协议，它们之间有一些关键的区别：</p>
<ol>
<li>
<p><strong>安全性：</strong></p>
<ul>
<li><strong>HTTP：</strong> 是明文传输的协议，数据在传输过程中是未加密的。这使得HTTP容易受到中间人攻击，例如窃听、篡改或劫持。</li>
<li><strong>HTTPS：</strong> 使用了TLS/SSL协议进行数据加密，确保在数据传输的过程中，中间人无法轻易窃听或篡改传输的数据。因此，HTTPS提供了更高的安全性。</li>
</ul>
</li>
<li>
<p><strong>端口号：</strong></p>
<ul>
<li><strong>HTTP：</strong> 默认使用端口号80。</li>
<li><strong>HTTPS：</strong> 默认使用端口号443。因为HTTPS引入了加密层，因此需要使用不同的端口号以确保安全通信。</li>
</ul>
</li>
<li>
<p><strong>加密方式：</strong></p>
<ul>
<li><strong>HTTP：</strong> 以明文方式传输数据，不提供加密。</li>
<li><strong>HTTPS：</strong> 使用TLS/SSL协议对数据进行加密，确保传输的数据在客户端和服务器之间是安全的。</li>
</ul>
</li>
<li>
<p><strong>证书要求：</strong></p>
<ul>
<li><strong>HTTP：</strong> 不需要证书。</li>
<li><strong>HTTPS：</strong> 需要服务器端使用SSL证书，该证书由受信任的证书颁发机构（CA，Certificate Authority）签发。这确保客户端与服务器之间建立的连接是可信任的。</li>
</ul>
</li>
<li>
<p><strong>使用场景：</strong></p>
<ul>
<li><strong>HTTP：</strong> 适用于不涉及敏感信息传输的场景，如浏览网页、阅读新闻等。</li>
<li><strong>HTTPS：</strong> 建议用于涉及敏感信息传输的场景，如登录、支付、个人数据提交等，以确保数据的安全性。</li>
</ul>
</li>
<li>
<p><strong>性能：</strong></p>
<ul>
<li><strong>HTTP：</strong> 由于不涉及加密解密过程，通常比HTTPS在性能上更快。</li>
<li><strong>HTTPS：</strong> 由于加密解密的过程，可能会引入一些额外的性能开销。然而，现代的硬件和优化手段使得这种差异相对较小。</li>
</ul>
</li>
</ol>
<p>在今天的互联网环境中，推荐在涉及用户隐私和安全性的场景中使用HTTPS，以确保数据的保密性和完整性。大多数网站已经迁移到了HTTPS，以提供更安全的用户体验。</p>
<h3 id="get和post有什么区别">GET和POST有什么区别</h3>
<p>GET请求和POST请求是HTTP协议中两种常见的请求方法，它们在数据传输、安全性和用途等方面有一些区别：</p>
<ol>
<li>
<p><strong>数据传输方式：</strong></p>
<ul>
<li><strong>GET请求：</strong> 将参数附加在URL的末尾，以查询字符串的形式发送给服务器。例如，<code>http://example.com/page?name=value&amp;age=25</code>。</li>
<li><strong>POST请求：</strong> 将参数包含在请求的消息体中，而不是直接附加在URL上。数据通过请求头以及请求体传输给服务器。</li>
</ul>
</li>
<li>
<p><strong>安全性：</strong></p>
<ul>
<li><strong>GET请求：</strong> 参数在URL上明文可见，不适合传输敏感信息，因为这些信息会被保存在浏览器的历史记录、服务器日志等地方。</li>
<li><strong>POST请求：</strong> 参数在请求体中，相对于GET请求更安全，因为请求体的内容不会被保存在浏览器历史记录中，但仍然可能被记录在服务器日志中。</li>
</ul>
</li>
<li>
<p><strong>数据长度限制：</strong></p>
<ul>
<li><strong>GET请求：</strong> 对数据传输的长度有限制，因为数据附加在URL上，URL的长度受到浏览器和服务器的限制。</li>
<li><strong>POST请求：</strong> 通常允许传输更大量的数据，因为数据不附加在URL上，而是放在请求体中。</li>
</ul>
</li>
<li>
<p><strong>请求的幂等性：</strong></p>
<ul>
<li><strong>GET请求：</strong> 通常是幂等的，即对同一个URL的多次请求应该返回相同的结果。</li>
<li><strong>POST请求：</strong> 不一定是幂等的，它可能会引起服务器端的状态改变，每次请求的结果可能不同。</li>
</ul>
</li>
<li>
<p><strong>缓存：</strong></p>
<ul>
<li><strong>GET请求：</strong> 可以被浏览器缓存，可以被书签保存，也可以被浏览器历史记录保存。</li>
<li><strong>POST请求：</strong> 不会被浏览器缓存，不适合被保存在书签或历史记录中。</li>
</ul>
</li>
<li>
<p><strong>使用场景：</strong></p>
<ul>
<li><strong>GET请求：</strong> 适用于获取数据，如浏览器中的页面跳转、链接、搜索等。</li>
<li><strong>POST请求：</strong> 适用于提交表单数据、上传文件等，具有更多的数据传输选项。</li>
</ul>
</li>
</ol>
<p>总体而言，选择使用GET还是POST取决于具体的需求和用途。GET用于获取数据，而POST用于提交数据。GET请求更适合幂等和无副作用的操作，而POST请求更适合有副作用的操作，例如向服务器提交表单数据。</p>
<h3 id="http状态码">HTTP状态码</h3>
<p>下面是常见的HTTP状态码：200 - 请求成功;301 - 资源（网页等）被永久转移到其它URL;404 - 请求的资源（网页等）不存在;500 - 内部服务器错误。</p>
<!-- raw HTML omitted -->
<h3 id="常用端口">常用端口</h3>
<ol>
<li>
<p><strong>FTP (File Transfer Protocol)：</strong></p>
<ul>
<li><strong>用途：</strong> 用于在客户端和服务器之间传输文件。</li>
<li><strong>端口号：</strong> 21</li>
</ul>
</li>
<li>
<p><strong>SSH (Secure Shell)：</strong></p>
<ul>
<li><strong>用途：</strong> 安全外壳协议，用于在网络中加密传输数据。</li>
<li><strong>端口号：</strong> 22</li>
</ul>
</li>
<li>
<p><strong>HTTP (HyperText Transfer Protocol)：</strong></p>
<ul>
<li><strong>用途：</strong> 用于在Web浏览器和Web服务器之间传输超文本数据，通常用于访问网页。</li>
<li><strong>端口号：</strong> 80</li>
</ul>
</li>
<li>
<p><strong>HTTPS (HyperText Transfer Protocol Secure)：</strong></p>
<ul>
<li><strong>用途：</strong> 加密的HTTP协议，用于在Web浏览器和Web服务器之间安全地传输超文本数据。</li>
<li><strong>端口号：</strong> 443</li>
</ul>
</li>
<li>
<p><strong>SMTP (Simple Mail Transfer Protocol)：</strong></p>
<ul>
<li><strong>用途：</strong> 用于发送电子邮件的协议。</li>
<li><strong>端口号：</strong> 25</li>
</ul>
</li>
<li>
<p><strong>POP3 (Post Office Protocol version 3)：</strong></p>
<ul>
<li><strong>用途：</strong> 用于接收电子邮件的协议。</li>
<li><strong>端口号：</strong> 110</li>
</ul>
</li>
<li>
<p><strong>IMAP (Internet Message Access Protocol)：</strong></p>
<ul>
<li><strong>用途：</strong> 用于接收电子邮件的协议，支持在多个设备上同步邮件状态。</li>
<li><strong>端口号：</strong> 143</li>
</ul>
</li>
<li>
<p><strong>DNS (Domain Name System)：</strong></p>
<ul>
<li><strong>用途：</strong> 用于域名解析，将域名映射为对应的IP地址。</li>
<li><strong>端口号：</strong> 53</li>
</ul>
</li>
<li>
<p><strong>MySQL：</strong></p>
<ul>
<li><strong>用途：</strong> 用于MySQL数据库的通信。</li>
<li><strong>端口号：</strong> 3306</li>
</ul>
</li>
<li>
<p><strong>Redis：</strong></p>
<ul>
<li><strong>用途：</strong> 用于缓存、消息队列等的开源内存数据库。</li>
<li><strong>端口号：</strong> 6379（默认端口，可根据配置修改）</li>
</ul>
</li>
<li>
<p><strong>PHP-FPM：</strong></p>
<ul>
<li><strong>用途：</strong> PHP FastCGI 进程管理器，用于处理PHP脚本的高性能进程管理。</li>
<li><strong>端口号：</strong> 9000（默认端口，可根据配置修改）</li>
</ul>
</li>
<li>
<p><strong>SSL (Secure Sockets Layer)：</strong></p>
<ul>
<li><strong>用途：</strong> 用于在网络中提供加密安全通信。</li>
<li><strong>端口号：</strong> 443（常用于HTTPS）</li>
</ul>
</li>
</ol>
<h3 id="cookie和session的区别">Cookie和Session的区别</h3>
<p>Cookies（Cookie）和Session（会话）是用于在Web应用中跟踪用户状态和维护用户数据的两种主要机制，但它们在实现方式和使用场景上有一些区别：</p>
<p><strong>1. 存储位置：</strong></p>
<ul>
<li><strong>Cookie：</strong> 存储在客户端（用户浏览器）上，以文本文件的形式保存在用户的计算机上。</li>
<li><strong>Session：</strong> 存储在服务器上，通常以服务器上的一个文件或数据库记录的形式保存。</li>
</ul>
<p><strong>2. 数据安全性：</strong></p>
<ul>
<li><strong>Cookie：</strong> 相对不安全，因为存储在用户的计算机上，用户可以查看和编辑。</li>
<li><strong>Session：</strong> 相对安全，因为数据存储在服务器上，用户无法直接访问或修改。</li>
</ul>
<p><strong>3. 生命周期：</strong></p>
<ul>
<li><strong>Cookie：</strong> 可以设置过期时间，可以是会话级的（浏览器关闭后失效）或长时间的。</li>
<li><strong>Session：</strong> 通常在用户关闭浏览器或一定时间不活动后过期，取决于服务器的配置。</li>
</ul>
<p><strong>4. 存储内容：</strong></p>
<ul>
<li><strong>Cookie：</strong> 存储在客户端的小型文本数据，通常用于跟踪用户偏好、识别用户等。</li>
<li><strong>Session：</strong> 存储在服务器上，可用于存储较大的数据，通常包括用户的会话信息、状态等。</li>
</ul>
<p><strong>5. 跨页面访问：</strong></p>
<ul>
<li><strong>Cookie：</strong> 可以在不同页面之间共享，因为存储在客户端。</li>
<li><strong>Session：</strong> 通常通过在页面之间传递会话标识符（session ID）来实现跨页面访问。</li>
</ul>
<p><strong>6. 资源消耗：</strong></p>
<ul>
<li><strong>Cookie：</strong> 存储在客户端，不占用服务器资源。</li>
<li><strong>Session：</strong> 存储在服务器上，可能占用服务器资源，特别是在用户较多的情况下。</li>
</ul>
<p><strong>7. 使用场景：</strong></p>
<ul>
<li><strong>Cookie：</strong> 适用于存储少量且对安全性要求不高的数据，如用户偏好设置、广告跟踪等。</li>
<li><strong>Session：</strong> 适用于存储较大、对安全性要求较高的数据，如用户登录状态、购物车信息等。</li>
</ul>
<p>总体而言，Cookie和Session是Web开发中常用的两种机制，它们通常一起使用，以实现在Web应用中跟踪用户状态和维护用户数据的目的。选择使用哪种机制取决于应用的具体需求和安全考虑。</p>
<h3 id="cgifastcgiphp-fpm">CGI、FastCGI、PHP-FPM</h3>
<p><a href="https://cloud.tencent.com/developer/article/1538240">全面了解CGI、FastCGI、PHP-FPM</a></p>
<h3 id="php-fpmnginx通信原理">PHP-FPM+NGINX通信原理</h3>
<p><a href="https://cloud.tencent.com/developer/article/1543164">PHP-FPM+NGINX通信原理</a></p>
<h2 id="nosql">NoSQL</h2>
<h4 id="缓存击穿缓存穿透缓存雪崩httpswwwcnblogscomxm66p15196745html"><a href="https://www.cnblogs.com/xm66/p/15196745.html">缓存击穿、缓存穿透、缓存雪崩</a></h4>
<h3 id="redis">Redis</h3>
<p>以下是 Redis 支持的主要数据类型以及它们的应用场景和简要说明：</p>
<ul>
<li><strong>字符串（String）：</strong>
<ul>
<li><strong>说明：</strong> 存储单个值的字符串，是最简单的数据类型。</li>
<li><strong>应用场景：</strong> 缓存、计数器、分布式锁等。</li>
</ul>
</li>
<li><strong>哈希表（Hash）：</strong>
<ul>
<li><strong>说明：</strong> 键值对的集合，适合存储对象的多个属性。</li>
<li><strong>应用场景：</strong> 存储用户信息、对象的属性。</li>
</ul>
</li>
<li><strong>列表（List）：</strong>
<ul>
<li><strong>说明：</strong> 有序的字符串元素集合，可在头部或尾部插入或删除元素。</li>
<li><strong>应用场景：</strong> 消息队列、最新动态列表。</li>
</ul>
</li>
<li><strong>集合（Set）：</strong>
<ul>
<li><strong>说明：</strong> 无序且唯一的字符串元素集合。</li>
<li><strong>应用场景：</strong> 存储唯一标签、共同好友、点赞用户。</li>
</ul>
</li>
<li><strong>有序集合（Sorted Set）：</strong>
<ul>
<li><strong>说明：</strong> 与集合类似，但每个元素都有一个分数，可以按分数排序。</li>
<li><strong>应用场景：</strong> 排行榜、优先级队列。</li>
</ul>
</li>
<li><strong>位图（Bitmap）：</strong>
<ul>
<li><strong>说明：</strong> 用于位级别的操作，存储开关状态等。</li>
<li><strong>应用场景：</strong> 用户签到、统计在线用户。</li>
</ul>
</li>
<li><strong>HyperLogLog：</strong>
<ul>
<li><strong>说明：</strong> 用于基数估算（去重计数）。</li>
<li><strong>应用场景：</strong> 统计访问过网站的独立用户数量。</li>
</ul>
</li>
<li><strong>地理空间（Geospatial）：</strong>
<ul>
<li><strong>说明：</strong> 存储地理空间信息，支持空间索引。</li>
<li><strong>应用场景：</strong> 附近的人、地理位置搜索等。</li>
</ul>
</li>
<li><strong>流（Stream）：</strong>
<ul>
<li><strong>说明：</strong> 时间序列数据结构，支持有序、持久化的消息流。</li>
<li><strong>应用场景：</strong> 日志记录、事件溯源。</li>
</ul>
</li>
</ul>
<h3 id="redis持久化">Redis持久化</h3>
<p>Redis 持久化是一种将内存中的数据存储到硬盘上以防止数据丢失的机制。在 Redis 中，有两种主要的持久化方式：RDB（Redis Database Backup）和AOF（Append-Only File）。</p>
<h3 id="1-rdb-持久化">1. RDB 持久化：</h3>
<ul>
<li><strong>触发方式：</strong> 手动或定期触发。</li>
<li><strong>工作原理：</strong> 将当前内存中的数据快照保存到一个二进制文件中。这个文件包含了 Redis 在某个时间点的数据。</li>
<li><strong>优点：</strong> 适合用于备份和恢复，文件较小，恢复速度较快。</li>
<li><strong>缺点：</strong> 可能会有一定的数据丢失，因为 RDB 是定期执行的。</li>
</ul>
<h4 id="配置示例">配置示例：</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ae81ff">save 900 1      </span> <span style="color:#75715e"># 在 900 秒内，如果至少有 1 个 key 发生变化，则执行一次快照</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">save 300 10     </span> <span style="color:#75715e"># 在 300 秒内，如果至少有 10 个 key 发生变化，则执行一次快照</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">save 60 10000   </span> <span style="color:#75715e"># 在 60 秒内，如果至少有 10000 个 key 发生变化，则执行一次快照</span>
</span></span></code></pre></div><h3 id="2-aof-持久化">2. AOF 持久化：</h3>
<ul>
<li><strong>触发方式：</strong> 始终处于开启状态，数据发生变化时即时记录。</li>
<li><strong>工作原理：</strong> 记录每个写命令（写操作）到一个文件中，以追加的方式记录，该文件可以用于恢复数据。</li>
<li><strong>优点：</strong> 提供更好的持久性，可以降低数据丢失的可能性。</li>
<li><strong>缺点：</strong> 文件较大，恢复速度可能较慢。</li>
</ul>
<h4 id="配置示例-1">配置示例：</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ae81ff">appendonly yes      </span> <span style="color:#75715e"># 开启 AOF 持久化</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">appendfsync everysec</span> <span style="color:#75715e"># 每秒钟同步一次 AOF 文件，可以选择 always 或 no。</span>
</span></span></code></pre></div><h3 id="持久化选择和使用场景">持久化选择和使用场景：</h3>
<ul>
<li>
<p><strong>选择 RDB 持久化：</strong></p>
<ul>
<li>适用于对数据一定程度的数据丢失可以接受的场景。</li>
<li>适合用于备份和恢复。</li>
</ul>
</li>
<li>
<p><strong>选择 AOF 持久化：</strong></p>
<ul>
<li>需要更高的数据安全性，对数据的可靠性要求较高的场景。</li>
<li>对于需要追踪数据变更历史的场景。</li>
</ul>
</li>
</ul>
<h4 id="注意">注意：</h4>
<ol>
<li>也可以同时使用 RDB 和 AOF 持久化，以兼顾备份和数据恢复的需求。</li>
<li>持久化的方式可以根据具体的业务需求和对数据安全性的要求进行调整。</li>
</ol>
<h3 id="rdb-和-aof恢复优先级对比">RDB 和 AOF恢复优先级对比</h3>
<ol>
<li>
<p><strong>AOF 恢复优先于 RDB：</strong></p>
<ul>
<li>如果同时启用了 AOF（Append-Only File）和 RDB（Redis Database Backup）持久化，Redis 在启动时会优先使用 AOF 文件进行数据恢复。AOF 文件包含了每个写命令的记录，能够提供更高的数据安全性。</li>
</ul>
</li>
<li>
<p><strong>AOF 文件的同步方式影响恢复优先级：</strong></p>
<ul>
<li>如果 AOF 文件的同步方式为 <code>always</code>（始终同步），则 Redis 在启动时会强制将 AOF 文件中的数据同步到内存中，确保数据的完整性。这时，即使存在 RDB 快照，AOF 仍然优先。</li>
<li>如果 AOF 文件的同步方式为 <code>everysec</code>（每秒同步），则 Redis 在启动时会尽量使用 AOF 文件进行恢复，但可能会根据同步的时间点有一定的数据丢失。此时，如果存在 RDB 文件，则会考虑使用 RDB 进行恢复。</li>
</ul>
</li>
<li>
<p><strong>RDB 文件作为备用：</strong></p>
<ul>
<li>RDB 文件通常用于备份和恢复，可以在需要时手动加载或用于定期备份。当 AOF 文件无法使用或需要降低数据恢复时间时，RDB 可作为一个备用的、更快速的恢复方式。</li>
</ul>
</li>
<li>
<p><strong>启用 AOF 时的 RDB 文件恢复：</strong></p>
<ul>
<li>如果 AOF 文件存在但损坏，Redis 在启动时会检查是否存在有效的 RDB 文件。如果 RDB 文件存在且有效，可以用于恢复数据。</li>
</ul>
</li>
</ol>
<p>总体而言，AOF 文件提供了更强的数据安全性，但在某些情况下可能导致恢复时间较长。RDB 文件则提供了较快的恢复速度，但在保存快照的过程中可能存在一定的数据丢失。根据业务需求和对数据安全性的要求，可以选择合适的持久化配置。</p>
<h3 id="redismemcache-和mongodb-的区别">Redis、Memcache 和、MongoDB 的区别</h3>
<ol>
<li>
<p><strong>Redis:</strong></p>
<ul>
<li><strong>类型：</strong> Redis 是一个基于内存的键值存储系统，属于 NoSQL 数据库。</li>
<li><strong>数据模型：</strong> Redis支持丰富的数据结构，如字符串、哈希表、列表、集合等。</li>
<li><strong>用途：</strong> 主要用于缓存、会话存储、消息队列等，也可用作持久化存储。</li>
<li><strong>特点：</strong> 非常快速，支持持久化，具有丰富的数据类型和强大的原子操作。</li>
</ul>
</li>
<li>
<p><strong>Memcache:</strong></p>
<ul>
<li><strong>类型：</strong> Memcache 也是一个基于内存的键值存储系统，属于分布式缓存系统。</li>
<li><strong>数据模型：</strong> Memcache 是一个简单的键值对存储系统，只支持字符串作为值。</li>
<li><strong>用途：</strong> 用于缓存，提高 Web 应用的性能。</li>
<li><strong>特点：</strong> 简单、快速，主要用于缓存，但不支持持久化和复杂的数据结构。</li>
</ul>
</li>
<li>
<p><strong>MongoDB:</strong></p>
<ul>
<li><strong>类型：</strong> MongoDB 是一个面向文档的 NoSQL 数据库。</li>
<li><strong>数据模型：</strong> MongoDB 存储数据的基本单元是文档，这是一种类似于 JSON 格式的数据结构。</li>
<li><strong>用途：</strong> 适用于需要存储和查询复杂文档结构的应用，例如大数据和实时应用。</li>
<li><strong>特点：</strong> 支持复杂的查询和索引，适用于大规模的数据存储和实时分析。</li>
</ul>
</li>
</ol>
<p><strong>主要区别：</strong></p>
<ul>
<li><strong>数据模型：</strong> Redis 和 Memcache 是键值存储系统，存储简单的键值对，而 MongoDB 是文档存储系统，存储复杂的文档结构。</li>
<li><strong>数据类型：</strong> Redis 支持丰富的数据类型，包括字符串、哈希表、列表、集合等，而 Memcache 只支持字符串。MongoDB 存储的是文档，具有更灵活的数据模型。</li>
<li><strong>用途：</strong> Redis 和 Memcache 主要用于缓存，提高读取性能。MongoDB 适用于需要存储和查询复杂文档结构的应用。</li>
<li><strong>持久化：</strong> Redis 支持持久化，可以将数据保存到磁盘。Memcache 不支持持久化。MongoDB 也支持持久化，并提供复制和分片机制。</li>
</ul>
<h2 id="设计模式">设计模式</h2>
<h3 id="工厂模式">工厂模式</h3>
<p>在工作中，我们经常会遇到复杂的对象实例化过程，这时候可以使用工厂模式来实现。
例如在一个订单系统中，需要根据不同的订单信息生成不同的订单对象，此时可以使用工厂模式来
实例化相应的对象。</p>
<h3 id="单例模式">单例模式</h3>
<p>在工作中也会遇到需要使用到共享数据或者共享资源的情况，此时可以采用单例模式来
保证整个应用中只有一个实例存在。</p>
<h3 id="模板方法模">模板方法模</h3>
<p>在工作中，我们经常会遇到需要重复执行一些步骤的情况，但是这些步骤之间可能
会有一些变化。此时可以使用模板方法模式来实现。例如在一个订单处理流程中，需要重复执行根
据不同订单信息生成不同的订单对象、根据不同的售后信息生成不同的售后对象、根据不同的物流
信息生成不同的物流对象等步骤。</p>
<h3 id="策略模式">策略模式</h3>
<p>在工作中，我们经常会遇到需要根据不同的情况采取不同的处理方法的情况，此时可以
使用策略模式来实现。例如在一个购物系统中，需要根据不同的用户身份采取不同的优惠方式（例
如新用户优惠、老用户优惠、VIP 会员优惠等）。此时就可以使用策略模式来实现这些功能。</p>
<h3 id="适配器模式">适配器模式</h3>
<p>在工作中，我们经常会遇到需要将一个接口转换成另一个接口的情况，此时就可以使
用适配器模式来实现。例如在一个数据库访问系统中，不同的数据库有不同的访问方式（例如
MySQL、Oracle、MongoDB 等）。此时就可以使用适配器来将这些不同的访问方式适配到相同的
API 接口上。</p>
<h3 id="代理模式">代理模式</h3>
<p>在工作中，我们经常会遇到需要对一个对象进行控制访问的情况，此时可以使用代理模
式来实现。例如在一个文件上传系统中，需要对用户上传的文件进行安全性校验（例如文件格式、
大小、是否有效等）。此时就可以使用代理模式来将安全性校验逻辑和文件上传逻辑分隔开。</p>
<h3 id="装饰者模式">装饰者模式</h3>
<p>在工作中，我们经常会遇到需要对一个对象进行功能增强的情况，此时可以使用装饰
者模式来实现。例如在一个电商系统中，可以使用装饰者模式来将不同的促销方法装饰到商品上
（例如打折、买赠、免运费等）。</p>
<h3 id="外观模式">外观模式</h3>
<p>在工作中，我们经常会遇到需要对一系列复杂的子系统进行封装的情况，此时可以使用
外观模式来实现。例如在一个订单处理流程中，可以将根据不同的订单信息生成不同的订单对象、
根据不同的售后信息生成不同的售后对象、根据不同的物流信息生成不同的物流对象这些功能封装
到一个外部服务中。</p>
<h2 id="其他">其他</h2>
<h3 id="elasticsearch">Elasticsearch</h3>
<p>Elasticsearch（ES）是一个开源的分布式搜索引擎，基于Apache Lucene构建。它提供了一个强大且灵活的全文搜索和分析引擎，广泛应用于构建实时搜索、日志分析、数据可视化等场景。</p>
<p><strong>特点：</strong></p>
<ol>
<li>
<p><strong>分布式架构：</strong> Elasticsearch是一个分布式系统，可以通过集群中的多个节点来处理大规模数据。这使得它具有横向扩展的能力，可以处理大量的数据和请求。</p>
</li>
<li>
<p><strong>文档存储：</strong> 数据以文档的形式存储，通常使用JSON格式。每个文档都有一个唯一的ID，并且属于一个类型。多个文档组合在一起形成一个索引。</p>
</li>
<li>
<p><strong>索引：</strong> 索引是具有相似结构的文档的集合。它们被用来进行搜索、过滤和排序。每个索引都有一个唯一的名称。</p>
</li>
<li>
<p><strong>全文搜索：</strong> Elasticsearch 提供了强大的全文搜索功能，支持复杂的查询，包括通配符搜索、模糊搜索、短语匹配等。</p>
</li>
<li>
<p><strong>实时性：</strong> Elasticsearch提供实时搜索，意味着一旦文档被索引，就可以立即进行搜索，而不需要等待。</p>
</li>
<li>
<p><strong>多语言支持：</strong> 支持多种编程语言，包括Java、Python、JavaScript等，通过RESTful API进行交互。</p>
</li>
<li>
<p><strong>聚合和分析：</strong> Elasticsearch不仅用于搜索，还支持对数据进行聚合、分析和统计。它提供了强大的聚合框架，允许用户按照各种条件对数据进行分析。</p>
</li>
<li>
<p><strong>开放源代码：</strong> Elasticsearch是开源的，可以根据需求进行定制和扩展。它的灵活性和强大的社区支持使其成为许多应用和系统中的首选搜索引擎。</p>
</li>
<li>
<p><strong>插件生态系统：</strong> Elasticsearch拥有丰富的插件生态系统，可以用于增强其功能，包括安全插件、监控插件、可视化工具等。</p>
</li>
</ol>
<p>Elasticsearch通常与Logstash和Kibana一同使用，构成所谓的ELK（Elasticsearch, Logstash, Kibana）堆栈，用于日志分析和实时数据可视化。这个堆栈使得用户可以方便地收集、处理、分析和可视化数据。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>
<p><strong>学习曲线：</strong> 对于初学者来说，Elasticsearch有一定的学习曲线，尤其是在配置和优化方面。</p>
</li>
<li>
<p><strong>资源消耗：</strong> Elasticsearch在处理大量数据时可能需要较多的硬件资源，包括内存和存储。</p>
</li>
<li>
<p><strong>复杂性：</strong> 对于一些简单的使用场景，Elasticsearch的强大功能可能显得过于复杂。</p>
</li>
<li>
<p><strong>实时性限制：</strong> 尽管Elasticsearch提供了近实时的索引和搜索，但对于对实时性要求极高的场景，可能仍有局限性。</p>
</li>
<li>
<p><strong>数据一致性：</strong> 在分布式环境中，数据一致性可能面临一些挑战，需要通过配置和调优来处理。</p>
</li>
<li>
<p><strong>存储成本：</strong> 由于Elasticsearch需要保存原始数据和索引数据，存储成本可能相对较高。</p>
</li>
</ol>
<p>虽然Elasticsearch有一些缺点，但在大多数场景下，其优点远远超过了缺点，特别是对于需要强大搜索和分析能力的应用。选择是否使用Elasticsearch通常取决于具体的应用需求和技术架构。</p>
<h4 id="防sql注入">防SQL注入</h4>
<p>1.对用户的输入进行校验，可以通过正则表达式，函数等。tp框架中的config.php文件可配置全局过滤规则。
<code>'default_filter' =&gt; 'htmlspecialchars,addslashes,strip_tags'</code><br>
<!-- raw HTML omitted -->htmlspecialchars<!-- raw HTML omitted -->：防XSS攻击，把预定义的字符 &ldquo;&lt;&rdquo; （小于）和 &ldquo;&gt;&rdquo; （大于）转换为 HTML 实体。 <em>htmlspecialchars_ decode() 函数把一些预定义的 HTML 实体转换为字符。</em> tip：Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。<br>
<!-- raw HTML omitted -->addslashes<!-- raw HTML omitted -->：防SQL注入。addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。预定义字符是：
单引号（&rsquo;）双引号（&quot;）反斜杠（\）NULL。<em>stripslashes()：删除由 addslashes() 函数添加的反斜杠。</em><br>
<!-- raw HTML omitted -->strip_tags<!-- raw HTML omitted -->：剥去字符串中的 HTML 标签。<br>
2.可以使用预处理语句l或者直接使用存储过程进行数据查询存取。<br>
3.不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。<br>
4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。<br>
5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装。</p>
<h4 id="预防csrf攻击">预防CSRF攻击</h4>
<p>验证HTTP Referer字段。<br>
请求中添加token并验证。<br>
TIP:CSRF（Cross-Site Request Forgery）的全称是“跨站请求伪造”，也被称为“One Click Attack”或者“Session Riding”，通常缩写为CSRF或者XSRF。CSRF的中文名称尽管听起来像跨站脚本攻击（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来攻击受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。<br>
CSRF和XSS的区别：XSS更偏向于方法论，CSRF更偏向于一种形式，只要是伪造用户发起的请求，都可成为CSRF攻击。 &hellip; XSS更偏向于代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了。</p>
<h4 id="高并发处理">高并发处理</h4>
<p>1.资源。能静态实现的就静态实现，静态资源也要尽量使用分布式存储，例如七牛云等云存储。
2.效率。PHP代码里，尽量注意内存的使用，单个脚本的运行效率要Ok.
3.缓存。使用memcache来实现非持久存储，使用no-sql来实现持久存储。
4.server。使用nginx+fpm或者nginx+apache，来实现动静态分离访问。
5.mysql。作为最终的存储库以及一些不可避免的实时调用库，做主从处理，Master+多Slave，多个只读副本来实现实时的调用库。
6.负载。建议架设一层负载均衡，来实现web server的轮询。例如云平台中的LBS</p>
<h4 id="跨域">跨域</h4>
<p><a href="https://www.cnblogs.com/niuben/p/13273336.html">跨域处理</a></p>
<h4 id="时间复杂度和空间复杂度">时间复杂度和空间复杂度</h4>
<p>时间复杂度*******</p>

        </div>
    </div>
    <a href="#" id="scrollToTopButton">
        <svg t="1686753152588" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
            p-id="3988" width="48" height="48">
            <path
                d="M518.5 360.3c-3.2-4.4-9.7-4.4-12.9 0l-178 246c-3.8 5.3 0 12.7 6.5 12.7H381c10.2 0 19.9-4.9 25.9-13.2L512 460.4l105.2 145.4c6 8.3 15.6 13.2 25.9 13.2H690c6.5 0 10.3-7.4 6.5-12.7l-178-246z"
                p-id="3989" fill="#363636"></path>
            <path
                d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64z m0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
                p-id="3990" fill="#363636"></path>
        </svg>
    </a><hr style="border-top: 1px solid #EEEEEE;">
<div id="comment"></div>
<script>
    const getStoredTheme = () => localStorage.getItem("theme") === "dark" ? "dark" : "light";

    const setGiscusTheme = () => {
        const sendMessage = (message) => {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (iframe) {
                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');
            }
        }
        sendMessage({setConfig: {theme: getStoredTheme()}})
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "wnagDouble\/wnagdouble.github.io",
            "data-repo-id": "R_kgDOKL5y6g",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDOKL5y6s4Cb9eJ",
            "data-mapping": "og:title",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "zh-CN",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
            ([key, value]) => giscusScript.setAttribute(key, value));
        document.getElementById("comment").appendChild(giscusScript);

        
        const themeToggle = document.querySelector(".theme-toggle");
        if (themeToggle) {
            themeToggle.addEventListener("click", setGiscusTheme);
        }
    });

</script>


<div class="pp-container">
        <section class="pre-and-post">
            <div class="has-text-left">
                
                <p>Previous post</p>
                <a href="https://WangDouble-Dev.github.io/post/github_explorer/">Github GraphQL API</a>
                
            </div>
            <div class="has-text-right">
                
            </div>
        </section>
    </div>

</div>

        </main><footer class="footer">
    <div class="content has-text-centered">
    <span>&copy; 2024 <a href="https://WangDouble-Dev.github.io/">Double Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" target="_blank">Hugo</a> &
        <a href="https://github.com/hotjuicew/hugo-JuiceBar" target="_blank">JuiceBar</a>
    </span>
    </div>
  </footer></body>
</html>

